import 'dart:io';

import 'package:path/path.dart' as path;

import '../models/image.dart';
import '../models/desktop.dart';

import '../common/utils.dart';

import '../src/logger.dart';
import '../src/image.dart';

/// Generates Linux platform-specific code for the native splash screen
///
/// Takes a [config] object containing splash screen configuration,
/// a [flavor] string to support multiple build flavors,
/// and an output [path] to override the default location.
///
/// Returns [true] if generation was successful, [false] otherwise.
Future<bool> generateLinuxCode({
  required DesktopSplashConfig config,
  required String flavor,
  required Directory outputDir,
}) async {
  // Validate image file exists
  final imageFile = File(config.imagePath);
  if (!imageFile.existsSync()) {
    logger.e('Image file not found: ${config.imagePath}');
    return false;
  }

  // Load and process the image
  final BGRAImage? imageData = await _loadAndProcessImage(config);
  if (imageData == null) {
    return false;
  }

  // Generate the C++ source file
  return _generateSourceFile(
    outputDir: outputDir.path,
    flavor: flavor,
    config: config,
    imageData: imageData,
  );
}

/// Loads and processes the splash screen image according to configuration
///
/// Returns the processed [BGRAImage] or null if processing failed
Future<BGRAImage?> _loadAndProcessImage(DesktopSplashConfig config) async {
  try {
    return await loadImageAsBGRA(
      config.imagePath,
      blurRadius: config.imageBlurRadius,
      resizeToFit: config.imageScaling,
      imageBorderRadius: config.imageBorderRadius,
      targetWidth: config.imageWidth,
      targetHeight: config.imageHeight,
      backgroundBorderRadius: config.backgroundBorderRadius,
      backgroundColor: config.backgroundColor,
      backgroundWidth: config.backgroundWidth,
      backgroundHeight: config.backgroundHeight,
    );
  } catch (e) {
    logger.e('Failed to load or process the image: $e');
    return null;
  }
}

/// Generates the C++ source file with image data and configuration
///
/// Returns [true] if file generation was successful, [false] otherwise
Future<bool> _generateSourceFile({
  required String outputDir,
  required String flavor,
  required DesktopSplashConfig config,
  required BGRAImage imageData,
}) async {
  final target = 'native_splash_screen_$flavor.cc';

  // Create complete file path using the output directory
  final String outputFilePath = path.join(outputDir, target);

  final outputFile = File(outputFilePath);

  try {
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// Generated file - do not edit');
    buffer.writeln('// Generated by native_splash_screen_cli');
    buffer.writeln('');

    // Splash screen configuration
    _writeConfigSection(buffer, config, imageData);

    // Image data
    _writeImageDataSection(buffer, imageData);

    // Write to file
    await outputFile.writeAsString(buffer.toString());
    // logger.success('Generated $target in $outputDir');
    return true;
  } catch (e) {
    logger.e('Failed to generate $target file: $e');
    return false;
  }
}

/// Writes the configuration section of the C++ file
void _writeConfigSection(
  StringBuffer buffer,
  DesktopSplashConfig config,
  BGRAImage imageData,
) {
  buffer.writeln('// Splash screen properties');
  buffer.writeln('int native_splash_screen_width = ${config.windowWidth};');
  buffer.writeln('int native_splash_screen_height = ${config.windowHeight};');
  buffer.writeln('');

  buffer.writeln('// Window Title');
  buffer.writeln(
    'const char* native_splash_screen_title = "${escapeString(config.windowTitle)}";',
  );
  buffer.writeln('');

  buffer.writeln('// Background color (ARGB format)');
  buffer.writeln(
    'unsigned int native_splash_screen_background_color = 0x${colorHex(config.windowColor)};',
  );
  // buffer.writeln(
  //   'unsigned int native_splash_screen_background_color = 0x00000000;',
  // );
  buffer.writeln('');

  buffer.writeln('// Animation control');
  buffer.writeln(
    'bool native_splash_screen_with_animation = ${config.withAnimation};',
  );
  buffer.writeln('');

  buffer.writeln('// Image dimensions');
  buffer.writeln('int native_splash_screen_image_width = ${imageData.width};');
  buffer.writeln(
    'int native_splash_screen_image_height = ${imageData.height};',
  );
  buffer.writeln('');
}

/// Writes the image data section of the C++ file
void _writeImageDataSection(StringBuffer buffer, BGRAImage imageData) {
  final length = imageData.data.length;

  buffer.writeln('// Raw image data in (ARGB) format');
  buffer.writeln(
    'const unsigned char native_splash_screen_image_data[$length] = {',
  );

  // Write data in a formatted way (16 values per line)
  const int valuesPerLine = 16;
  for (int i = 0; i < length; i++) {
    if (i % valuesPerLine == 0) {
      buffer.write('  ');
    }

    final hex =
        imageData.data[i].toRadixString(16).padLeft(2, '0').toUpperCase();
    buffer.write('0x$hex');

    if (i != length - 1) {
      buffer.write(', ');
      if ((i + 1) % valuesPerLine == 0) {
        buffer.writeln();
      }
    }
  }

  buffer.writeln('');
  buffer.writeln('};');

  buffer.writeln('');
  buffer.writeln('// Pointer to image data');
  buffer.writeln(
    'const unsigned char* native_splash_screen_image_pixels = native_splash_screen_image_data;',
  );
}
