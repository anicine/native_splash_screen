import 'dart:io';

import 'package:path/path.dart' as path;

import '../models/image.dart';
import '../models/desktop.dart';

import '../common/utils.dart';

import '../src/logger.dart';
import '../src/image.dart';

/// Generates Windows platform-specific code for the native splash screen
///
/// Takes a [config] object containing splash screen configuration,
/// a [flavor] string to support multiple build flavors,
/// and an output [outputDir] to override the default location.
///
/// Returns [true] if generation was successful, [false] otherwise.
Future<bool> generateWindowsCode({
  required DesktopSplashConfig config,
  required String flavor,
  required Directory outputDir,
}) async {
  // Validate image file exists
  final imageFile = File(config.imagePath);
  if (!imageFile.existsSync()) {
    logger.e('Image file not found: ${config.imagePath}');
    return false;
  }

  // Load and process the image
  final BGRAImage? imageData = await _loadAndProcessImage(config);
  if (imageData == null) {
    return false;
  }

  // Generate the C++ source file
  return _generateSourceFile(
    outputDir: outputDir.path,
    flavor: flavor,
    config: config,
    imageData: imageData,
  );
}

/// Loads and processes the splash screen image according to configuration
///
/// Returns the processed [BGRAImage] or null if processing failed
Future<BGRAImage?> _loadAndProcessImage(DesktopSplashConfig config) async {
  try {
    return await loadImageAsBGRA(
      config.imagePath,
      blurRadius: config.imageBlurRadius,
      resizeToFit: config.imageScaling,
      imageBorderRadius: config.imageBorderRadius,
      targetWidth: config.imageWidth,
      targetHeight: config.imageHeight,
      backgroundBorderRadius: config.backgroundBorderRadius,
      backgroundColor: config.backgroundColor,
      backgroundWidth: config.backgroundWidth,
      backgroundHeight: config.backgroundHeight,
    );
  } catch (e) {
    logger.e('Failed to load or process the image: $e');
    return null;
  }
}

/// Generates the C++ source file with image data and configuration
///
/// Returns [true] if file generation was successful, [false] otherwise
Future<bool> _generateSourceFile({
  required String outputDir,
  required String flavor,
  required DesktopSplashConfig config,
  required BGRAImage imageData,
}) async {
  final target = 'native_splash_screen_$flavor.cpp';

  // Create complete file path using the output directory
  final String outputFilePath = path.join(outputDir, target);

  final outputFile = File(outputFilePath);

  try {
    final buffer = StringBuffer();

    // File header
    buffer.writeln('// Generated file - do not edit');
    buffer.writeln('// Generated by native_splash_screen_cli');
    buffer.writeln('');
    buffer.writeln('#include <cstdint>');
    buffer.writeln('');
    buffer.writeln('');
    buffer.writeln('#ifdef __cplusplus');
    buffer.writeln('extern "C" {');
    buffer.writeln('#endif');
    buffer.writeln('');
    buffer.writeln('');

    // Splash screen configuration
    _writeConfigSection(buffer, config, imageData);

    // Image data
    _writeImageDataSection(buffer, imageData);

    buffer.writeln('');
    buffer.writeln('');
    buffer.writeln('#ifdef __cplusplus');
    buffer.writeln('}  // extern "C"');
    buffer.writeln('#endif');

    // Write to file
    await outputFile.writeAsString(buffer.toString());
    // logger.success('Generated $target in $outputDir');
    return true;
  } catch (e) {
    logger.e('Failed to generate $target file: $e');
    return false;
  }
}

/// Writes the configuration section of the C++ file
void _writeConfigSection(
  StringBuffer buffer,
  DesktopSplashConfig config,
  BGRAImage imageData,
) {
  buffer.writeln('// Splash screen properties');
  buffer.writeln('int native_splash_screen_width = ${config.windowWidth};');
  buffer.writeln('int native_splash_screen_height = ${config.windowHeight};');

  buffer.writeln('');
  buffer.writeln('// Window Title');
  buffer.writeln(
    'const wchar_t* native_splash_screen_title = L"${escapeString(config.windowTitle)}";',
  );
  buffer.writeln('');
  buffer.writeln('// Window class name');
  buffer.writeln(
    'const wchar_t* native_splash_screen_window_class = L"${escapeString(config.windowClass)}";',
  );

  buffer.writeln('');
  buffer.writeln('// Animation control');
  buffer.writeln(
    'bool native_splash_screen_with_animation = ${config.withAnimation};',
  );
  buffer.writeln('');

  buffer.writeln('// Image dimensions');
  buffer.writeln('int native_splash_screen_image_width = ${imageData.width};');
  buffer.writeln(
    'int native_splash_screen_image_height = ${imageData.height};',
  );
  buffer.writeln('');
}

/// Writes the image data section of the C++ file
void _writeImageDataSection(StringBuffer buffer, BGRAImage imageData) {
  final data = imageData.data;
  final length = data.length ~/ 4;

  buffer.writeln('// Raw image data in (ARGB) format');
  buffer.writeln('const uint32_t native_splash_screen_image_data[$length] = {');

  // Write data in a formatted way (4 values per line)
  const int valuesPerLine = 4;
  for (int i = 0; i < data.length; i += valuesPerLine) {
    if (i % valuesPerLine == 0) {
      buffer.write('  ');
    }

    final b = data[i + 0];
    final g = data[i + 1];
    final r = data[i + 2];
    final a = data[i + 3];

    final hex = (a << 24) | (r << 16) | (g << 8) | b;
    buffer.write('0x${hex.toRadixString(16).padLeft(8, '0').toUpperCase()}');

    if (i + valuesPerLine < data.length) {
      buffer.write(',');
      if (((i ~/ valuesPerLine) + 1) % valuesPerLine == 0) {
        buffer.writeln();
      }
    }
  }
  buffer.writeln('');
  buffer.writeln('};');

  buffer.writeln('');
  buffer.writeln('// Pointer to image data');
  buffer.writeln(
    'const uint32_t* native_splash_screen_image_pixels = native_splash_screen_image_data;',
  );
}
