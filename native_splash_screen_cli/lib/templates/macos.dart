import 'dart:io';

import 'package:path/path.dart' as path;
import 'package:image/image.dart' as img;

import '../models/image.dart';
import '../models/desktop.dart';

import '../common/utils.dart';

import '../src/logger.dart';
import '../src/image.dart';

/// Generates Macos platform-specific code for the native splash screen
///
/// Takes a [config] object containing splash screen configuration,
/// a [flavor] string to support multiple build flavors,
/// and an output [outputDir] to override the default location.
///
/// Returns [true] if generation was successful, [false] otherwise.
Future<bool> generateMacosCode({
  required DesktopSplashConfig config,
  required String flavor,
  required Directory outputDir,
}) async {
  if (!File(config.imagePath).existsSync()) {
    logger.e('Image file not found: ${config.imagePath}');
    return false;
  }

  // --- High-Quality Asset Generation ---
  // To ensure maximum quality, we generate both 1x and 2x assets directly
  // from the original source image, preventing any quality loss from upscaling.

// 1. Determine the final LOGICAL canvas dimensions.
  //    Fall back to window size if image size is not specified.
  final int logicalWidth =
      config.imageWidth > 0 ? config.imageWidth : config.windowWidth;
  final int logicalHeight =
      config.imageHeight > 0 ? config.imageHeight : config.windowHeight;

  // 2. Generate the 1x asset using the logical dimensions.
  final BGRAImage? processedImage1x =
      await _loadAndProcessImage(config, logicalWidth, logicalHeight);
  if (processedImage1x == null) return false;

  // 3. Generate the 2x asset using doubled logical dimensions.
  final BGRAImage? processedImage2x = await _loadAndProcessImage(
      config, logicalWidth * 2, logicalHeight * 2,
      scale: 2.0);
  if (processedImage2x == null) return false;

  // Save the generated high-quality assets to the xcassets bundle.
  final imageFileName = await _generateMacosAssets(
    outputDir: outputDir.path,
    flavor: flavor,
    processedImage1x: processedImage1x,
    processedImage2x: processedImage2x,
  );
  if (imageFileName == null) {
    return false;
  }

  // Generate the Swift source file.
  return _generateSourceFile(
    outputDir: outputDir.path,
    flavor: flavor,
    config: config,
    imageFileName: imageFileName,
    logicalWidth: logicalWidth,
    logicalHeight: logicalHeight,
  );
}

/// Saves the pre-processed 1x and 2x images into the `.imageset` directory.
///
/// This function no longer performs any image manipulation; its sole responsibility
/// is to save the high-quality assets generated by the calling function.
///
/// Returns the base filename of the generated image asset.
Future<String?> _generateMacosAssets({
  required String outputDir,
  required String flavor,
  required BGRAImage processedImage1x,
  required BGRAImage processedImage2x,
}) async {
  try {
    final assetsDir = Directory(path.join(outputDir, 'Assets.xcassets'));
    if (!assetsDir.existsSync()) {
      logger.w('Assets.xcassets not found, skipping asset generation.');
      return null;
    }

    final baseFileName = 'splash_screen_$flavor';
    final imageSetName = '$baseFileName.imageset';
    final imageSetDir = Directory(path.join(assetsDir.path, imageSetName));
    if (!imageSetDir.existsSync()) imageSetDir.createSync(recursive: true);

    // Save the 1x asset
    final fileName1x = '$baseFileName.png';
    final assetImagePath1x = path.join(imageSetDir.path, fileName1x);
    await _saveBGRAImageAsPNG(processedImage1x, assetImagePath1x);

    // Save the 2x asset
    final fileName2x = '$baseFileName@2x.png';
    final assetImagePath2x = path.join(imageSetDir.path, fileName2x);
    await _saveBGRAImageAsPNG(processedImage2x, assetImagePath2x);

    // Create the Contents.json manifest
    final contentsJson = '''
{
  "images" : [
    { "filename" : "$fileName1x", "idiom" : "mac", "scale" : "1x" },
    { "filename" : "$fileName2x", "idiom" : "mac", "scale" : "2x" }
  ],
  "info" : { "author" : "native_splash_screen_cli", "version" : 1 }
}''';
    await File(path.join(imageSetDir.path, 'Contents.json'))
        .writeAsString(contentsJson);

    logger.i('Generated Retina assets in $imageSetName:');
    logger.i('  - 1x (${processedImage1x.width}x${processedImage1x.height})');
    logger.i('  - 2x (${processedImage2x.width}x${processedImage2x.height})');

    return fileName1x; // Return the base 1x filename for the Swift code
  } catch (e) {
    logger.e('Failed to generate macOS image assets: $e');
    return null;
  }
}

// Modify _loadAndProcessImage to accept the target dimensions and scale factor.
Future<BGRAImage?> _loadAndProcessImage(
    DesktopSplashConfig config, int targetWidth, int targetHeight,
    {double scale = 1.0}) async {
  try {
    return await loadImageAsBGRA(
      config.imagePath,
      ensureCanvasSize: true, // This is essential for macOS
      resizeToFit: config.imageScaling,
      targetWidth: targetWidth,
      targetHeight: targetHeight,
      // Scale effects like blur and radius for the 2x asset
      blurRadius: config.imageBlurRadius * scale,
      imageBorderRadius: config.imageBorderRadius * scale,
      backgroundBorderRadius: config.backgroundBorderRadius * scale,
      // The background must also fill the target canvas
      backgroundColor: config.backgroundColor,
      backgroundWidth: targetWidth,
      backgroundHeight: targetHeight,
    );
  } catch (e) {
    logger.e('Failed to process image: $e');
    return null;
  }
}

/// Converts BGRAImage data to a standard `img.Image` format.
img.Image _bgraToImage(BGRAImage bgra) {
  // Implementation assumes this helper correctly converts BGRA to img.Image
  return img.Image.fromBytes(
    width: bgra.width,
    height: bgra.height,
    bytes: bgra.data.buffer,
    order: img.ChannelOrder.bgra,
  );
}

/// Saves a BGRAImage as a PNG file.
Future<void> _saveBGRAImageAsPNG(BGRAImage imageData, String outputPath) async {
  final image = _bgraToImage(imageData);
  await File(outputPath).writeAsBytes(img.encodePng(image));
}

/// Generates the Swift source file that configures the splash screen.
Future<bool> _generateSourceFile({
  required String outputDir,
  required String flavor,
  required DesktopSplashConfig config,
  required String imageFileName,
  required int logicalWidth,
  required int logicalHeight,
}) async {
  final build = flavor.capitalizeFirstLetter();
  final target = 'NativeSplashScreen_$build.swift';
  final outputFilePath = path.join(outputDir, target);

  try {
    final buffer = StringBuffer();
    buffer.writeln('// Generated file - do not edit');
    buffer.writeln('// Generated by native_splash_screen_cli');
    buffer.writeln('');
    buffer.writeln('import native_splash_screen_macos');
    buffer.writeln('');
    _writeConfigSection(
      buffer,
      config,
      build,
      imageFileName,
      logicalWidth,
      logicalHeight,
    );
    await File(outputFilePath).writeAsString(buffer.toString());
    return true;
  } catch (e) {
    logger.e('Failed to generate $target file: $e');
    return false;
  }
}

/// Writes the configuration section of the Swift file.
void _writeConfigSection(
  StringBuffer buffer,
  DesktopSplashConfig config,
  String build,
  String imageFileName,
  int logicalWidth,
  int logicalHeight,
) {
  buffer.writeln(
    'class ${build}NativeSplashScreenConfiguration: NativeSplashScreenConfigurationProvider {',
  );
  buffer.writeln('');
  buffer.writeln('    // MARK: - Splash screen properties');
  buffer.writeln('    let windowWidth: Int = ${config.windowWidth}');
  buffer.writeln('    let windowHeight: Int = ${config.windowHeight}');
  buffer.writeln('');

  buffer.writeln('    // MARK: - Window Title');
  buffer.writeln(
    '    let windowTitle: String = "${escapeString(config.windowTitle)}"',
  );
  buffer.writeln('');

  buffer.writeln('    // MARK: - Animation control');
  buffer.writeln('    let withAnimation: Bool = ${config.withAnimation}');
  buffer.writeln('');

  buffer.writeln('    // MARK: - Image properties');
  buffer.writeln('    let imageFileName: String = "$imageFileName"');
  // Use logical display size from config (not the physical pixel size)
  buffer.writeln('    let imageWidth: Int = $logicalWidth');
  buffer.writeln('    let imageHeight: Int = $logicalHeight');
  buffer.writeln('}');
}
